runApp('ResilRiskInds_C/ResilianceApp')
vars()
file_options[[input$indicator_1ind]]
vars()
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
paste(unlist(opt_values),collapse="-")
opt_values
opt_needed
opt_names
unlist(opt_in)
unlist(opt_in())
opt_in$seasons
opt_values[opt_in]
opt_values[which(opt_in)]
opt_values <- list(input$seasons1,
input$units1,
input$RPs1,
input$accs1,
input$APs1,
input$exceeds1,
input$severities1)
opt_values
input$seasons1
input$options1
input$seasons
input$unit
input$season
isolate(input$seasons)
isolate(input$seasons1)
isolate(input$options1)
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
vars()
om
om
runApp('ResilRiskInds_C/ResilianceApp')
opt_values
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
opt_values
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp', display.mode="showcase")
input$units
input$units
input$seasons
Q
runApp('ResilRiskInds_C/ResilianceApp')
input$units
input$cmtype1
dim(centreMaster_single)
input$seasons
input$seasons
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
input$cmtype1
input$location_1ind
input$units
Q
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp()
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
centreMaster_single$cm_type == input$cmtype1 &
centreMaster_single$location == input$location_1ind &
centreMaster_single$loc_type == input$loc_type1 &
centreMaster_single$indicator == input$indicator_1ind &
centreMaster_single$ind_opts == om
centreMaster_single$cm_type == input$cmtype1
centreMaster_single[1:3,]
meanMaster_single[1:3,]
exemplarMaster_single[1:3,]
dataMaster_single[1:3,]
runApp('ResilRiskInds_C/ResilianceApp')
centreMaster_single$cm_type == input$cmtype1 &
centreMaster_single$location == input$location_1ind &
centreMaster_single$loc_type == input$loc_type1 &
centreMaster_single$indicator == input$indicator_1ind &
centreMaster_single$ind_opts == om
centreMaster_single$cm_type == input$cmtype1
centreMaster_single$cm_type == input$cmtype1 & centreMaster_single$location == input$location_1ind
input$location
input$location_1ind
input$location1ind
centreMaster_single$cm_type == input$cmtype1 &
centreMaster_single$location == input$location_1ind &
centreMaster_single$loc_type == input$loc_type1 &
centreMaster_single$indicator == input$indicator_1ind &
centreMaster_single$ind_opts == om
cmtype1
input$cmtype1
input$indicator_1ind
om <- "_"
centreMaster_single$cm_type == input$cmtype1 &
centreMaster_single$location == input$location_1ind &
centreMaster_single$loc_type == input$loc_type1 &
centreMaster_single$indicator == input$indicator_1ind &
centreMaster_single$ind_opts == om
which(centreMaster_single$cm_type == input$cmtype1 &
centreMaster_single$location == input$location_1ind &
centreMaster_single$loc_type == input$loc_type1 &
centreMaster_single$indicator == input$indicator_1ind &
centreMaster_single$ind_opts == om)
which(meanMaster_single$cm_type == input$cmtype1 &
meanMaster_single$location == input$location_1ind &
meanMaster_single$loc_type == input$loc_type1 &
meanMaster_single$indicator == input$indicator_1ind &
meanMaster_single$ind_opts == om)
runApp('ResilRiskInds_C/ResilianceApp')
input$seasons
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
input$cm$type1
input$cmtype1
dim(LINES$centreLines)
LINES$centreLines
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
which(centreMaster_single$cm_type == input$cmtype1)
which(centreMaster_single$location == input$location_1ind)
input$location_1ind
adminList
runApp('ResilRiskInds_C/ResilianceApp')
LINES$centreLines
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp()
Q
runApp('ResilRiskInds_C/ResilianceApp')
dim(LINES$centreLines)
colnames(LINES$centreLines)
runApp('ResilRiskInds_C/ResilianceApp')
LINE$centreLines
LINES$centreLines
LINES$centreLines
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
opt_names
opt_values
input$seasons
opt_values
Q
runApp('ResilRiskInds_C/ResilianceApp')
runApp('ResilRiskInds_C/ResilianceApp')
opt_values
opt_needed
reactiveValuesToList(opt_in)
opt_names
names(opt_names)
opt_needed <- reactiveValuesToList(opt_in)
opt_names <- option_names[opt_needed]
opt_needed
opt_values <- list(input$seasons,
input$units,
input$RPs,
input$accs,
input$APs,
input$exceeds,
input$severities)
opt_values
opt_values <- list(seasons=input$seasons,
units=input$units,
RPs=input$RPs,
accs=input$accs,
APs=input$APs,
exceeds=input$exceeds,
severities=input$severities)
opt_values
sapplu(opt_names, function(x){ifelse(x,1,0)})
sapply(opt_names, function(x){ifelse(x,1,0)})
sapply(opt_needed, function(x){ifelse(x,1,0)})
#~~~~~~~~~~~~~~~~~~~~~~~
# Adam Griffin, 2020-06-15
#
# The Empirical Copula functions
#
# For aquaCAT, Project 07441.
#
# Created ABG 2020-06-15
#
#~~~~~~~~~~~~~~~~~~~~~~~
##### SETUP #####---------------------------------------------------
library(ncdf4)
library(extRemes)
library(dplyr)
library(readr)
library(fitdistrplus)
if (substr(osVersion,1,3) == "Win") {
ncname <- "S:/CodeABG/InterimData/dmflow_copy.nc"  # rechunked for spaceslices
ncname2 <- "S:/run_hmfg2g/outputs/dmflow_RCM01_198012_201011_out.nc"
# pre-rechunk
wd <- "S:/"
wd_id <- "S:/CodeABG/InterimData/"
wd_cd <- "S:/CodeABG/"
} else {
ncname <- "/prj/aquacat/CodeABG/InterimData/dmflow_copy.nc"
ncname2 <- "S:/run_hmfg2g/outputs/dmflow_RCM01_198012_201011_out.nc"
wd <- "/prj/aquacat/"
wd_id <- "/prj/aquacat/CodeABG/InterimData/"
wd_cd <- "/prj/aquacat/CodeABG/"
}
### DATA --------------------------
# print(ST <- Sys.time())
# ncin <- nc_open(ncname) # This file is ~2.5GB on the linux server.
# print(ncin)
# print(floor(Sys.time() - ST))
ND <- 10800 # Number of days
# river network
rn <- read_csv(paste0(wd_id, "hasData2.csv"))
NH <- nrow(rn)
# threshold for inundation
threshVal <- c(5/365, 2/365, 1/365, 0.2/365, 0.1/365)
threshName <- c("POT5", "POT2", "POT1", "Q5", "Q10")
NT <- length(threshVal)
# cut-off bound for widespread event
wsBound <- c(0.05, 0.02, 0.01, 0.005, 0.001)
wsName <- c("pc5", "pc2", "pc1", "pc05", "pc01")
NW <- length(wsBound)
# lists of which days different thresholds were exceeded at different points
# NT lists of NW lists
threshDayExcList <- readRDS(paste0(wd_id, "threshDayExcList2.rds"))
# matrix of threshold value (col) at a given cell (row)
threshMat <- read_csv(paste0(wd_id, "threshMat2.csv"))
#dim(threshMat)  =  19914 x 5
# eventLList length of event L, NT lists (by threshold) of NW lists
# (by inun cutoff))
# eventDayList start of event L, NT lists of NW lists
load(paste0(wd_id, "eventLists03.RDa"))
NE <- length(eventDayList[[2]][[4]]) # POT2, 2% inun.
# timewise maxima at each cell for each event ((NE + 2) x NH)
eventDF <- readr::read_csv(paste0(wd,"Data/eventdf_POT2_pc05.csv"))
# PoE under different computations with extra data. Tidy format.
present <- readr::read_csv(paste0(wd,"Data/present2_returnlevels.csv"))
dummy <- readr::read_csv(paste0(wd, "Data/dummy1_returnlevels.csv"))
##### COPULA FUNCTIONS #####---------------------------------------------------
# Get event set
# select event
tailsGen <- function(n, low=1, pool=present$gpp, maxit=1000, betapar=c(1,1)){
# draw new probabilities of exceedence from pool, allowing minumum lower bound
# to be enforced. Technically drawing from the conditional distribution
# P[X=x | X_i < low for some i].
#
# n         number of PoEs to draw
# low       lower target on PoE
# pool      existing PoE to take quantiles from.
# maxit     number of trials to get an event of the required probability
# betapar   vector of two parameters for the Beta distribution
QV <- rep(2, n)
#TODO needs the right distribution to extrapolate from pool to reach tails.
z <- 0
while(min(QV) > low){
V <- runif(n)
z <- z+1
QV <- qbeta(V, betapar[1], betapar[2])
if(z >= maxit){
print("maxit exceeded")
break
}
}
if(z>1){print(paste(z, "iterations."))}
unname(QV)
}
generateNewEvent <- function(eventSet=present, NE=285, NH=19914,
maxit=10000, low=1, pool=present$gpp, betapar=c(1,1)){
# generates a new widespread event based on a given event library
#
# eventSet  object like present1_return_levels.csv, needs the right col names
# NE        number of events in the set
# NH        number of gridpoints involved (~20000 in standard set)
U <- sample.int(NE, 1)
eventSubset <-  eventSet %>% filter(eventNo == U)
rankNew <- rank(eventSubset$gpp, ties.method="random")
eventMags <- tailsGen(NH, low=low, pool=pool, maxit=maxit, betapar=betapar)
# add the magnitudes according to rank
magsNew <- sort(eventMags)[rankNew]
df <- eventSubset[c("loc", "Northing", "Easting")]
df$rank <- rankNew
df$gpp <- magsNew
df$low <- low
df
}
FF <- fitdist(dummy$gpp, "beta", method="mle")
M1 <- generateNewEvent(eventSet=dummy, NE=NE, NH=3, maxit=100,
pool=dummy$gpp, low=0.01, betapar=FF$estimate)
print(M1)
# Get ranking according to PoE per event
NH <- 3
M <- 1000 # number of new events
newEventMat <- matrix(NA, nrow=NH, ncol=M)
FF
debug(generateNewEvent)
M1 <- generateNewEvent(eventSet=dummy, NE=NE, NH=3, maxit=100,
pool=dummy$gpp, low=0.01, betapar=FF$estimate)
df
M1
print(M1)
# Get ranking according to PoE per event
NH <- 3
M <- 1000 # number of new events
newEventMat <- matrix(NA, nrow=NH, ncol=M)
FF <- fitdist(present$gpp, "beta", method="mle")
